<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Chat</title>
    <link href="./src/styles/common.css" rel="stylesheet" />
    <!-- Load Font Awesome via link instead of @import to avoid any raw CSS render issues -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <!-- PrismJS theme for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
    <style>
      /* Font Awesome now loaded via <link> above */

      body {
        background: transparent !important;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }

      .chat-container {
        width: 100%;
        height: 100vh;
        background: linear-gradient(
          135deg,
          rgba(0, 0, 0, 0.3) 0%,
          rgba(20, 20, 20, 0.4) 100%
        );
        backdrop-filter: blur(25px);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 25px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
        -webkit-app-region: drag;
      }
      .chat-header {
        padding: 16px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        display: flex;
        align-items: center;
        justify-content: space-between;
        -webkit-app-region: drag;
        background: rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(10px);
        cursor: move;
        flex-shrink: 0;
      }
      .header-title {
        color: rgba(255, 255, 255, 0.95);
        font-size: 14px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      }
      /* Header actions (e.g., Clear History) */
      .header-actions {
        -webkit-app-region: no-drag;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .icon-button {
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.18);
        color: rgba(255, 255, 255, 0.9);
        border-radius: 6px;
        padding: 6px 10px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .icon-button:hover {
        background: rgba(255, 255, 255, 0.22);
        color: #fff;
      }
      .recording-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #ff4757;
        animation: pulse 2s infinite;
        display: none;
        box-shadow: 0 0 10px rgba(255, 71, 87, 0.5);
      }
      @keyframes pulse {
        0% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.7;
          transform: scale(1.1);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }
      .chat-messages {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-app-region: no-drag;
        box-sizing: border-box;
        /* Removed max-height restriction */
      }
      .message {
        margin-bottom: 16px;
        padding: 12px 16px;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        border-left: 3px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(5px);
        word-wrap: break-word;
        word-break: break-word;
        /* Removed all height restrictions */
        position: relative;
      }
      .message.transcription {
        background: rgba(76, 175, 80, 0.15);
        animation: fadeInSlide 0.1s ease-out;
        position: relative;
      }

      .message.transcription::before {
        position: absolute;
        left: -8px;
        top: 8px;
        font-size: 12px;
        color: white;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      @keyframes fadeInSlide {
        from {
          opacity: 0;
          transform: translateX(-20px);
          background: rgba(76, 175, 80, 0.3);
        }
        to {
          opacity: 1;
          transform: translateX(0);
          background: rgba(76, 175, 80, 0.15);
        }
      }
      .message.system {
        background: rgba(33, 150, 243, 0.1);
      }
      .message.error {
        background: rgba(244, 67, 54, 0.1);
      }
      .message.user {
        background: rgba(255, 152, 0, 0.1);
      }
      .message.assistant {
        background: rgba(156, 39, 176, 0.1);
        border-left: 3px solid #9c27b0;
        /* Removed all height restrictions and overflow hidden */
        display: block;
      }
      
      .message.assistant .message-text {
        /* Removed all height restrictions and overflow hidden */
        white-space: pre-wrap;
        word-wrap: break-word;
        word-break: break-word;
        overflow-wrap: break-word;
      }
      
      /* Ensure all content in assistant messages is fully visible */
      .message.assistant *,
      .message.assistant .bullet-point,
      .message.assistant .numbered-point,
      .message.assistant strong,
      .message.assistant em,
      .message.assistant code,
      .message.assistant pre,
      .message.assistant ul,
      .message.assistant ol,
      .message.assistant li,
      .message.assistant h1,
      .message.assistant h2,
      .message.assistant h3,
      .message.assistant h4,
      .message.assistant h5,
      .message.assistant h6,
      .message.assistant p,
      .message.assistant blockquote {
        /* Remove all height restrictions */
        height: auto !important;
        max-height: none !important;
        overflow: visible !important;
      }
      
      /* Markdown formatting for assistant messages */
      .message.assistant .bullet-point {
        margin: 4px 0;
        padding-left: 8px;
        line-height: 1.4;
        word-wrap: break-word;
        word-break: break-word;
        overflow-wrap: break-word;
      }
      
      .message.assistant .numbered-point {
        margin: 4px 0;
        padding-left: 16px;
        line-height: 1.4;
        position: relative;
        counter-increment: list-counter;
        word-wrap: break-word;
        word-break: break-word;
        overflow-wrap: break-word;
      }
      
      .message.assistant .numbered-point::before {
        content: counter(list-counter) ". ";
        position: absolute;
        left: 0;
        font-weight: 500;
        color: rgba(156, 39, 176, 0.8);
      }
      
      .message.assistant {
        counter-reset: list-counter;
      }
      
      .message.assistant strong {
        font-weight: 600;
        color: rgba(255, 255, 255, 1);
      }
      
      .message.assistant em {
        font-style: italic;
        color: rgba(255, 255, 255, 0.9);
      }
      
      .message.assistant code {
        background: rgba(0, 0, 0, 0.3);
        padding: 2px 4px;
        border-radius: 3px;
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 11px;
        color: #64ffda;
        display: inline;
      }
      
      /* Ensure code blocks are fully visible */
      .message.assistant pre {
        background: rgba(0, 0, 0, 0.4);
        padding: 8px 12px;
        border-radius: 6px;
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 11px;
        color: #64ffda;
        overflow-x: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        margin: 8px 0;
        position: relative;
      }
      
      .message.assistant pre code {
        background: transparent;
        padding: 0;
        border-radius: 0;
        display: block;
      }

      /* Copy button in code blocks */
      .copy-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.5);
        color: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 4px 8px;
        font-size: 11px;
        border-radius: 4px;
        cursor: pointer;
        -webkit-app-region: no-drag;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.12s ease;
      }
      .copy-btn:hover {
        background: rgba(0,0,0,0.7);
      }
      .copy-btn.copied {
        background: rgba(76, 175, 80, 0.8);
        border-color: rgba(76, 175, 80, 0.9);
        transform: scale(0.98);
      }
      
      /* Ensure lists are fully visible */
      .message.assistant ul,
      .message.assistant ol {
        margin: 8px 0;
        padding-left: 20px;
      }
      
      .message.assistant li {
        margin: 4px 0;
        line-height: 1.4;
      }
      
      /* Ensure headings are fully visible */
      .message.assistant h1,
      .message.assistant h2,
      .message.assistant h3,
      .message.assistant h4,
      .message.assistant h5,
      .message.assistant h6 {
        margin: 12px 0 8px 0;
        font-weight: 600;
        color: rgba(255, 255, 255, 1);
      }
      
      .message.assistant h1 { font-size: 16px; }
      .message.assistant h2 { font-size: 15px; }
      .message.assistant h3 { font-size: 14px; }
      .message.assistant h4,
      .message.assistant h5,
      .message.assistant h6 { font-size: 13px; }
      
      /* Ensure paragraphs are fully visible */
      .message.assistant p {
        margin: 8px 0;
      }
      
      /* Ensure blockquotes are fully visible */
      .message.assistant blockquote {
        border-left: 3px solid rgba(156, 39, 176, 0.5);
        padding-left: 12px;
        margin: 8px 0;
        font-style: italic;
        color: rgba(255, 255, 255, 0.8);
      }
      
      /* Thinking indicator animation */
      .thinking-dots {
        display: flex;
        align-items: center;
        gap: 2px;
      }
      
      .thinking-dots .dot {
        opacity: 0.4;
        animation: thinking 1.4s infinite ease-in-out;
      }
      
      .thinking-dots .dot:nth-child(1) { animation-delay: 0s; }
      .thinking-dots .dot:nth-child(2) { animation-delay: 0.2s; }
      .thinking-dots .dot:nth-child(3) { animation-delay: 0.4s; }
      
      @keyframes thinking {
        0%, 80%, 100% {
          opacity: 0.4;
          transform: scale(1);
        }
        40% {
          opacity: 1;
          transform: scale(1.2);
        }
      }
      
      .message.thinking {
        animation: fadeIn 0.3s ease-out;
      }
      
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .message-time {
        color: rgba(255, 255, 255, 0.6);
        font-size: 11px;
        margin-bottom: 4px;
        font-weight: 500;
      }
      .message-text {
        color: rgba(255, 255, 255, 0.95);
        font-size: 13px;
        line-height: 1.4;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        word-wrap: break-word;
        word-break: break-word;
        white-space: pre-wrap;
        overflow-wrap: break-word;
        max-width: 100%;
        display: block;
      }
      .chat-input {
        padding: 16px 20px;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        -webkit-app-region: no-drag;
        background: rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(10px);
        flex-shrink: 0;
      }
      .input-container {
        display: flex;
        align-items: center;
        gap: 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 8px 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        -webkit-app-region: no-drag;
      }
      .input-field {
        flex: 1;
        background: transparent;
        border: none;
        color: rgba(255, 255, 255, 0.95);
        font-size: 13px;
        outline: none;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        /* make it work well as multiline */
        resize: none;
        line-height: 1.4;
        min-height: 32px;
        max-height: 140px;
        overflow-y: auto;
      }
      .input-field:focus {
        outline: none;
      }
      .input-field::placeholder {
        color: rgba(255, 255, 255, 0.5);
      }
      .send-button {
        background: rgba(255, 255, 255, 0.15);
        border: none;
        border-radius: 6px;
        padding: 6px 10px;
        color: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        transition: all 0.2s;
        -webkit-app-region: no-drag;
      }
      .send-button:hover {
        background: rgba(255, 255, 255, 0.25);
        color: rgba(255, 255, 255, 1);
      }
      .status-message {
        text-align: center;
        color: rgba(255, 255, 255, 0.7);
        font-size: 12px;
        padding: 20px;
        font-style: italic;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }
      .error-message {
        color: #ff4757;
        font-size: 12px;
        padding: 10px;
        text-align: center;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      }
      .mic-button {
        background: rgba(255, 255, 255, 0.15);
        border: none;
        border-radius: 6px;
        padding: 6px 10px;
        color: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        transition: all 0.2s;
        -webkit-app-region: no-drag;
      }
      .mic-button:hover {
        background: rgba(255, 255, 255, 0.25);
        color: rgba(255, 255, 255, 1);
      }
      .mic-button.recording {
        background: rgba(255, 71, 87, 0.8);
        color: white;
        box-shadow: 0 0 15px rgba(255, 71, 87, 0.4);
      }
      .help-text {
        color: rgba(255, 255, 255, 0.7);
        font-size: 11px;
        text-align: center;
        padding: 10px;
        line-height: 1.4;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }
      .interaction-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: rgba(255, 255, 255, 0.9);
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
        z-index: 1000;
      }
      .interaction-indicator.show {
        opacity: 1;
      }
      .interaction-indicator.interactive {
        background: rgba(76, 175, 80, 0.9);
      }
      .interaction-indicator.non-interactive {
        background: rgba(244, 67, 54, 0.9);
      }
      .non-interactive .input-container {
        pointer-events: none;
        opacity: 0.5;
      }
      .non-interactive .mic-button {
        pointer-events: none;
        opacity: 0.5;
      }
      .non-interactive .send-button {
        pointer-events: none;
        opacity: 0.5;
      }

      /* Minimalist Listening Animation */
      .listening-indicator {
        display: none;
        position: fixed;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(203, 203, 203, 0.3);
        border-radius: 20px;
        padding: 8px 16px;
        z-index: 1000;
        pointer-events: none;
      }

      .listening-indicator.active {
        display: flex;
        align-items: center;
        gap: 8px;
        animation: fadeInUp 0.3s ease-out;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .listening-wave {
        display: flex;
        align-items: center;
        gap: 2px;
      }

      .wave-bar {
        width: 2px;
        background: #4caf50;
        border-radius: 1px;
        animation: waveAnimation 1.2s infinite ease-in-out;
      }

      .wave-bar:nth-child(1) {
        height: 8px;
        animation-delay: 0s;
      }
      .wave-bar:nth-child(2) {
        height: 12px;
        animation-delay: 0.15s;
      }
      .wave-bar:nth-child(3) {
        height: 16px;
        animation-delay: 0.3s;
      }
      .wave-bar:nth-child(4) {
        height: 12px;
        animation-delay: 0.45s;
      }
      .wave-bar:nth-child(5) {
        height: 8px;
        animation-delay: 0.6s;
      }

      @keyframes waveAnimation {
        0%, 100% {
          transform: scaleY(0.3);
          opacity: 0.6;
        }
        50% {
          transform: scaleY(1);
          opacity: 1;
        }
      }

      .listening-text {
        color: rgba(255, 255, 255, 0.9);
        font-size: 11px;
        font-weight: 500;
        letter-spacing: 0.5px;
      }

      .listening-duration {
        color: rgba(76, 175, 80, 0.8);
        font-size: 10px;
        font-family: monospace;
        margin-left: 4px;
      }

      /* Interim text overlay */
      .interim-overlay {
        position: fixed;
        bottom: 80px;
        left: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.028);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(76, 175, 80, 0.3);
        border-radius: 8px;
        padding: 12px;
        color: rgba(255, 255, 255, 0.8);
        font-size: 12px;
        font-style: italic;
        z-index: 999;
        pointer-events: none;
        display: none;
        animation: slideUpFade 0.3s ease-out;
      }

      .interim-overlay.active {
        display: block;
      }

      @keyframes slideUpFade {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>
  </head>
  <body>
    <div class="chat-container" id="chatContainer">
      <div class="chat-header">
        <div class="header-title">
          <i class="fas fa-microphone"></i>
          Live Transcription & Chat
          <div class="recording-indicator" id="recordingIndicator"></div>
        </div>
        <div class="header-actions">
          <button class="icon-button" id="clearHistoryBtn" title="Clear chat history">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>

      <!-- Interim Text Overlay -->
      <div class="interim-overlay" id="interimOverlay"></div>

      <div class="chat-messages" id="chatMessages"></div>

      <div class="chat-input">
        <div class="input-container">
          <textarea
            class="input-field"
            placeholder="Type a message… (Shift+Enter for newline)"
            id="messageInput"
            rows="1"
          ></textarea>
          <button class="mic-button" id="micButton" title="Start recording audio (microphone + system)" style="min-width:60px;padding:8px 12px;font-size:12px;font-weight:bold;">
            MIC
          </button>
          <button class="send-button" id="sendButton" title="Send message" style="min-width:60px;padding:8px 12px;font-size:12px;font-weight:bold;">
            SEND
          </button>
        </div>
      </div>
    </div>
    <script src="lib/markdown.js"></script> 
    <!-- PrismJS core and autoloader for language components -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
      // Configure Prism autoloader
      try { if (window.Prism && Prism.plugins && Prism.plugins.autoloader) { Prism.plugins.autoloader.languages_path = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/'; } } catch (_) {}
    </script>
    <script>
      // Use electronAPI from preload script instead of direct require
      const whysperAPI = window.electronAPI;

      const chatMessages = document.getElementById('chatMessages');
      const recordingIndicator = document.getElementById('recordingIndicator');
      const messageInput = document.getElementById('messageInput');
      const sendButton = document.getElementById('sendButton');
      const micButton = document.getElementById('micButton');
      const chatContainer = document.getElementById('chatContainer');
      const listeningIndicator = document.getElementById('listeningIndicator');
      const listeningDuration = document.getElementById('listeningDuration');
      const interimOverlay = document.getElementById('interimOverlay');
      const clearHistoryBtn = document.getElementById('clearHistoryBtn');

      let isRecording = false;
      let isInteractive = true;
      let listeningStartTime = null;
      let listeningTimer = null;
      let speechAvailable = false;

      // Audio recording for Whisper API
      let mediaRecorder = null;
      let audioChunks = [];
      let recordingStream = null;
      let isRecordingAudio = false;
      let recordingStartTime = null;

      // Whisper transcription interval (send audio every N seconds)
      const WHISPER_CHUNK_DURATION = 5000; // 5 seconds
      let whisperInterval = null;

      // Chat persistence and deduplication
      const CHAT_HISTORY_KEY = 'opencluely_chat_history_v1';
      let chatHistory = [];
      const recentResponseHashes = new Set();
      const RECENT_HASH_LIMIT = 50;

      function hashString(str) {
        try {
          let h = 2166136261 >>> 0; // FNV-1a
          for (let i = 0; i < str.length; i++) {
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 16777619);
          }
          return (h >>> 0).toString(16);
        } catch (_) {
          return String(str?.length || 0);
        }
      }

      function saveHistory() {
        try {
          localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(chatHistory.slice(-500)));
        } catch (e) {
          console.warn('Failed to save history', e);
        }
      }

      function loadHistory() {
        try {
          const raw = localStorage.getItem(CHAT_HISTORY_KEY);
          if (!raw) return;
          const items = JSON.parse(raw);
          if (Array.isArray(items)) {
            chatHistory = items;
            // Render
            items.forEach(item => {
              if (item.kind === 'message') {
                addMessage(item.text, item.type, true);
              } else if (item.kind === 'snippet') {
                addCodeSnippet(item.language, item.code, true);
              }
            });
          }
        } catch (e) {
          console.warn('Failed to load history', e);
        }
      }

      function clearChatHistory(skipConfirm = false) {
        if (!skipConfirm) {
          const ok = confirm('Clear chat history?');
          if (!ok) return;
        }
        chatHistory = [];
        saveHistory();
        // Clear DOM
        if (chatMessages) chatMessages.innerHTML = '';
      }

      function applyMicVisibility() {
        // Force mic button to always be visible for debugging
        if (micButton) {
          micButton.style.display = '';
          // Add text fallback if icon doesn't load
          if (!micButton.querySelector('i')) {
            micButton.textContent = 'MIC';
          }
        }
      }
      
      async function initSpeechAvailability() {
        try {
          if (window.electronAPI && window.electronAPI.getSpeechAvailability) {
            speechAvailable = await window.electronAPI.getSpeechAvailability();
            applyMicVisibility();
          }
        } catch (e) {
          speechAvailable = false;
          applyMicVisibility();
        }
      }
      
      // Listen for availability changes
      if (whysperAPI && whysperAPI.onSpeechAvailability) {
        whysperAPI.onSpeechAvailability((event, data) => {
          speechAvailable = !!(data && data.available);
          applyMicVisibility();
        });
      }
      
      // Also capture generic LLM responses (from OCR/screenshot flows)
      if (whysperAPI && whysperAPI.onLlmResponse) {
        whysperAPI.onLlmResponse((event, data) => {
          try { hideThinkingIndicator(); } catch (_) {}
          if (data && data.response) {
            renderAssistantResponse(data.response);
          }
        });
      }

      // Clear on session-cleared from main
      if (whysperAPI && whysperAPI.onSessionCleared) {
        whysperAPI.onSessionCleared(() => {
          clearChatHistory(true);
        });
      }

      // Initialize availability and history
      loadHistory();
      initSpeechAvailability();

      // Basic message function with markdown support for assistant messages
      function addMessage(text, type = 'user', skipPersist = false) {
        if (!chatMessages) {
          console.error('Chat messages element not found!');
          return;
        }

        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;

        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = new Date().toLocaleTimeString();

        const textDiv = document.createElement('div');
        textDiv.className = 'message-text';
        
        // Format assistant messages as markdown
        if (type === 'assistant') {
          textDiv.innerHTML = formatMarkdown(text);
        } else {
          textDiv.textContent = text;
        }

        messageDiv.appendChild(timeDiv);
        messageDiv.appendChild(textDiv);

        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        if (!skipPersist) {
          chatHistory.push({ kind: 'message', type, text });
          saveHistory();
        }
      }

      // Markdown formatter using markdown.js library
      function formatMarkdown(text) {
        if (!text) return '';
        
        try {
          if (typeof markdown !== 'undefined' && markdown.toHTML) {
            return markdown.toHTML(text);
          } else {
            console.warn('Markdown library not loaded, falling back to basic formatting');
            return text
              .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
              .replace(/\*(.+?)\*/g, '<em>$1</em>')
              .replace(/`(.+?)`/g, '<code>$1</code>')
              .replace(/\n/g, '<br>');
          }
        } catch (error) {
          console.error('Markdown parsing failed:', error);
          return text.replace(/\n/g, '<br>');
        }
      }

      // Show thinking indicator
      function showThinkingIndicator() {
        const thinkingDiv = document.createElement('div');
        thinkingDiv.className = 'message assistant thinking';
        thinkingDiv.id = 'thinking-indicator';

        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = new Date().toLocaleTimeString();

        const textDiv = document.createElement('div');
        textDiv.className = 'message-text thinking-dots';
        textDiv.innerHTML = '<span class="dot">•</span><span class="dot">•</span><span class="dot">•</span>';

        thinkingDiv.appendChild(timeDiv);
        thinkingDiv.appendChild(textDiv);

        chatMessages.appendChild(thinkingDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // Hide thinking indicator
      function hideThinkingIndicator() {
        const thinkingIndicator = document.getElementById('thinking-indicator');
        if (thinkingIndicator) {
          thinkingIndicator.remove();
        }
      }

      // Minimalist Listening Animation Functions
      function showListeningAnimation() {
        if (listeningIndicator) {
          listeningIndicator.classList.add('active');

          // Start timer
          listeningStartTime = Date.now();
          listeningTimer = setInterval(() => {
            if (listeningStartTime && listeningDuration) {
              const elapsed = Math.floor((Date.now() - listeningStartTime) / 1000);
              listeningDuration.textContent = `${elapsed}s`;
            }
          }, 1000);
        }
      }

      function hideListeningAnimation() {
        if (listeningIndicator) {
          listeningIndicator.classList.remove('active');
        }

        // Hide interim overlay
        if (interimOverlay) {
          interimOverlay.classList.remove('active');
        }

        // Clear timer
        if (listeningTimer) {
          clearInterval(listeningTimer);
          listeningTimer = null;
        }

        listeningStartTime = null;
      }

      function showInterimText(text) {
        if (!interimOverlay) return;

        if (text && text.trim()) {
          interimOverlay.textContent = text;
          interimOverlay.classList.add('active');
        } else {
          interimOverlay.classList.remove('active');
        }
      }

      // Audio Recording Functions for Whisper API
      async function startAudioRecording() {
        try {
          // Enumerate devices to find VoiceMeeter
          const devices = await navigator.mediaDevices.enumerateDevices();
          const audioDevices = devices.filter(device => device.kind === 'audioinput');

          console.log('Available audio devices:', audioDevices.map(d => d.label));

          // Try to find VoiceMeeter device (case insensitive)
          const voiceMeeterDevice = audioDevices.find(device =>
            device.label.toLowerCase().includes('voicemeeter') &&
            device.label.toLowerCase().includes('out')
          );

          let audioConstraints = {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
          };

          if (voiceMeeterDevice) {
            audioConstraints.deviceId = { exact: voiceMeeterDevice.deviceId };
            console.log('Using VoiceMeeter device:', voiceMeeterDevice.label);
          } else {
            console.warn('VoiceMeeter device not found, using default microphone');
          }

          // Request microphone access
          recordingStream = await navigator.mediaDevices.getUserMedia({
            audio: audioConstraints
          });

          // Log the actual audio track being used
          const audioTrack = recordingStream.getAudioTracks()[0];
          if (audioTrack) {
            const settings = audioTrack.getSettings();
            console.log('Audio track settings:', settings);
            console.log('Audio track label:', audioTrack.label);
          }

          // Try different audio formats for better Whisper compatibility
          // Whisper prefers: mp3, mp4, mpeg, mpga, m4a, wav, webm
          const preferredFormats = [
            'audio/mp4',
            'audio/mpeg',
            'audio/webm;codecs=opus',
            'audio/webm'
          ];

          let mimeType = 'audio/webm';  // fallback
          let fileExtension = 'webm';

          for (const format of preferredFormats) {
            if (MediaRecorder.isTypeSupported(format)) {
              mimeType = format;
              if (format.includes('mp4')) fileExtension = 'mp4';
              else if (format.includes('mpeg')) fileExtension = 'mp3';
              else fileExtension = 'webm';
              break;
            }
          }

          console.log('Using MIME type:', mimeType, 'Extension:', fileExtension);

          mediaRecorder = new MediaRecorder(recordingStream, {
            mimeType: mimeType,
            audioBitsPerSecond: 128000  // Higher bitrate for better quality
          });

          // Store file extension for later use
          window.currentRecordingExtension = fileExtension;

          audioChunks = [];

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
            }
          };

          mediaRecorder.onstop = async () => {
            if (audioChunks.length > 0) {
              await sendToWhisper();
            }
          };

          mediaRecorder.start();
          isRecordingAudio = true;
          recordingStartTime = Date.now();

          // Send audio chunks to Whisper every N seconds
          whisperInterval = setInterval(async () => {
            if (isRecordingAudio && audioChunks.length > 0) {
              // Stop and restart to get chunk
              mediaRecorder.stop();
              await new Promise(resolve => setTimeout(resolve, 100));
              if (isRecordingAudio) {
                audioChunks = [];
                mediaRecorder.start();
              }
            }
          }, WHISPER_CHUNK_DURATION);

          console.log('Audio recording started');
          handleRecordingStarted();

          // Show which device is being used
          const deviceMessage = voiceMeeterDevice
            ? `Recording from: ${voiceMeeterDevice.label}`
            : 'Recording from: Default Microphone (VoiceMeeter not found!)';
          addMessage(deviceMessage, 'system');
          addMessage('Recording audio from microphone and system...', 'system');
          return true;

        } catch (error) {
          console.error('Failed to start audio recording:', error);
          addMessage('Microphone access denied. Please allow microphone access.', 'error');
          return false;
        }
      }

      async function stopAudioRecording() {
        isRecordingAudio = false;

        if (whisperInterval) {
          clearInterval(whisperInterval);
          whisperInterval = null;
        }

        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }

        if (recordingStream) {
          recordingStream.getTracks().forEach(track => track.stop());
          recordingStream = null;
        }

        handleRecordingStopped();
        addMessage('Stopped recording', 'system');
        console.log('Audio recording stopped');
      }

      async function sendToWhisper() {
        if (audioChunks.length === 0) {
          console.log('No audio chunks to send');
          return;
        }

        try {
          // Use the same mime type that was used for recording
          const recordingMimeType = mediaRecorder?.mimeType || 'audio/webm';
          const audioBlob = new Blob(audioChunks, { type: recordingMimeType });
          console.log(`Sending ${audioBlob.size} bytes (${audioChunks.length} chunks) to Whisper`);
          addMessage(`Audio size: ${(audioBlob.size / 1024).toFixed(2)} KB`, 'system');

          // Create a download link for debugging
          const url = URL.createObjectURL(audioBlob);
          const a = document.createElement('a');
          a.style.display = 'none';
          a.href = url;
          const ext = window.currentRecordingExtension || 'webm';
          a.download = `recording_${Date.now()}.${ext}`;
          document.body.appendChild(a);
          console.log('Audio file available for download - click to save:', a);
          console.log('Download URL (copy and open in browser to listen):', url);
          console.log('File format:', recordingMimeType, 'Extension:', ext);

          console.log('Sending audio to Whisper API...', {
            size: audioBlob.size,
            chunks: audioChunks.length
          });

          // Send to backend to handle Whisper API call
          const result = await window.electronAPI.transcribeAudioWithWhisper(audioBlob);

          if (result && result.text && result.text.trim()) {
            console.log('Whisper transcription:', result.text);

            // Add transcription to chat with speaker label
            const labeledText = `[Audio] ${result.text.trim()}`;
            addMessage(labeledText, 'user');

            // Send to Gemini for response
            setTimeout(async () => {
              try {
                await window.electronAPI.sendChatMessage(result.text.trim());
              } catch (error) {
                console.error('Failed to send transcription to LLM:', error);
              }
            }, 300);
          }

        } catch (error) {
          console.error('Whisper API error:', error);
          addMessage('Transcription failed: ' + error.message, 'error');
        }
      }

      // Recording Event Handlers
      function handleRecordingStarted() {
        isRecording = true;

        if (recordingIndicator) {
          recordingIndicator.style.display = 'block';
        }
        if (micButton) {
          micButton.classList.add('recording');
        }

        showListeningAnimation();
      }

      function handleRecordingStopped() {
        isRecording = false;

        if (recordingIndicator) {
          recordingIndicator.style.display = 'none';
        }
        if (micButton) {
          micButton.classList.remove('recording');
        }

        hideListeningAnimation();
        addMessage('Stopped Listening', 'system');
      }

      function handleTranscription(text) {
        if (text && typeof text === 'string' && text.trim().length > 0) {
          // Hide listening animation first
          hideListeningAnimation();

          // Show transcribed text with slight delay for smooth transition
          setTimeout(() => {
            addMessage(text.trim(), 'transcription');
            
            // Show thinking indicator after transcription
            setTimeout(() => {
              showThinkingIndicator();
            }, 300);
          }, 200);
        } else {
          console.warn('Invalid or empty transcription text - ignoring:', text);
        }
      }

      // Helpers to capture AI response into chat (text + snippets)
      function extractCodeBlocks(text) {
        if (!text) return [];
        const blocks = [];
        const regex = /(```|~~~)([^\n]*)\n([\s\S]*?)\1/g; // supports ```lang and ~~~lang
        let match;
        while ((match = regex.exec(text)) !== null) {
          const info = (match[2] || '').trim();
          const langToken = info.split(/\s+/)[0] || 'text';
          blocks.push({ language: langToken, code: match[3], fullMatch: match[0] });
        }
        return blocks;
      }
      function stripCodeBlocks(text, blocks) {
        let result = text || '';
        blocks.forEach(b => { result = result.replace(b.fullMatch, ''); });
        return result.replace(/\n\s*\n\s*\n/g, '\n\n').trim();
      }
      function escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str ?? '';
        return div.innerHTML;
      }
      function attachCopy(btn, codeText) {
        if (!btn) return;
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          try {
            let ok = false;
            if (window.electronAPI && typeof window.electronAPI.copyToClipboard === 'function') {
              ok = await window.electronAPI.copyToClipboard(codeText);
            }
            if (!ok) {
              if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(codeText);
                ok = true;
              } else {
                const ta = document.createElement('textarea');
                ta.value = codeText;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                ta.remove();
                ok = true;
              }
            }
            if (ok) {
              btn.classList.add('copied');
              const original = btn.textContent;
              btn.textContent = 'Copied';
              setTimeout(() => { btn.classList.remove('copied'); btn.textContent = original || 'Copy'; }, 1200);
            }
          } catch (err) {
            console.warn('Copy failed', err);
          }
        });
      }
      function addCodeSnippet(language, code, skipPersist = false) {
        if (!chatMessages) return;
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message assistant';
        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = new Date().toLocaleTimeString();
        const textDiv = document.createElement('div');
        textDiv.className = 'message-text';

        const lang = (language || 'text').toLowerCase();
        const pre = document.createElement('pre');
        const codeEl = document.createElement('code');
        codeEl.className = `language-${lang}`;
        codeEl.innerHTML = escapeHtml(code || '');

        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Copy';
        attachCopy(copyBtn, code || '');

        pre.appendChild(copyBtn);
        pre.appendChild(codeEl);
        
        const label = document.createElement('div');
        label.style.cssText = 'font-size:12px;color:rgba(255,255,255,0.8);margin-bottom:6px;';
        label.textContent = `Snippet: ${lang.toUpperCase()}`;

        textDiv.appendChild(label);
        textDiv.appendChild(pre);

        messageDiv.appendChild(timeDiv);
        messageDiv.appendChild(textDiv);
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        try { if (window.Prism && Prism.highlightElement) { Prism.highlightElement(codeEl); } } catch (_) {}

        if (!skipPersist) {
          chatHistory.push({ kind: 'snippet', language: lang, code: code || '' });
          saveHistory();
        }
      }
      function renderAssistantResponse(response) {
        if (!response || typeof response !== 'string') return;
        // Deduplication: avoid processing the same response twice
        const normalized = response.trim();
        const h = hashString(normalized);
        if (recentResponseHashes.has(h)) return;
        recentResponseHashes.add(h);
        if (recentResponseHashes.size > RECENT_HASH_LIMIT) {
          const first = recentResponseHashes.values().next().value;
          recentResponseHashes.delete(first);
        }

        const blocks = extractCodeBlocks(response);
        const textOnly = stripCodeBlocks(response, blocks);
        // Add text response first (if any)
        if (textOnly && textOnly.trim().length) {
          addMessage(textOnly, 'assistant');
        }
        // Add each code snippet separately
        blocks.forEach(b => addCodeSnippet(b.language, b.code));
      }

      // Basic IPC Event Listeners - simplified
      
      // Listen for transcription events
      if (whysperAPI) {
        whysperAPI.onTranscriptionReceived((event, data) => {
          if (data && data.text) {
            handleTranscription(data.text);
          } else {
            console.warn('Invalid transcription data received:', data);
          }
        });

        whysperAPI.onInterimTranscription((event, data) => {
          if (data && data.text) {
            showInterimText(data.text);
          }
        });

        // Listen for speech status
        whysperAPI.onSpeechStatus((event, data) => {
          if (data && data.status) {
            addMessage(data.status, 'system');

            if (data.status.includes('started') || data.status.includes('Recording')) {
              handleRecordingStarted();
            } else if (data.status.includes('stopped') || data.status.includes('ended')) {
              handleRecordingStopped();
            }
          }
        });

        // Listen for speech errors
        whysperAPI.onSpeechError((event, data) => {
          if (data && data.error) {
            addMessage(`Error in recognizing speech`, 'error');
            handleRecordingStopped();
          }
        });

        // Listen for other events
        whysperAPI.onRecordingStarted(() => {
          handleRecordingStarted();
        });

        whysperAPI.onRecordingStopped(() => {
          handleRecordingStopped();
        });

        whysperAPI.onSessionCleared(() => {
          addMessage('Session memory has been cleared', 'system');
        });

        // Replace transcription LLM handler to store text + snippets
        whysperAPI.onTranscriptionLlmResponse((event, data) => {
          if (data && data.response) {
            try { hideThinkingIndicator(); } catch (_) {}
            renderAssistantResponse(data.response);
          }
        });

        // Dual Speech Event Listeners
        whysperAPI.onDualRecordingStarted(() => {
          handleRecordingStarted();
          addMessage('Dual audio capture started - listening to both microphone and system audio', 'system');
        });

        whysperAPI.onDualRecordingStopped(() => {
          handleRecordingStopped();
          addMessage('Dual audio capture stopped', 'system');
        });

        whysperAPI.onDualTranscriptionReceived((event, data) => {
          if (data && data.text && data.isFinal) {
            const speaker = data.speaker || (data.source === 'user' ? 'You' : 'Other Person');
            const labeledText = `[${speaker}] ${data.text}`;

            // Add message with speaker label
            addMessage(labeledText, data.source === 'user' ? 'user' : 'other');

            // Send to Gemini for response
            setTimeout(async () => {
              try {
                await window.electronAPI.sendChatMessage(data.text.trim());
              } catch (error) {
                console.error('Failed to send transcription to LLM:', error);
              }
            }, 300);
          }
        });

        whysperAPI.onDualInterimTranscription((event, data) => {
          if (data && data.text) {
            const speaker = data.speaker || (data.source === 'user' ? 'You' : 'Other Person');
            showInterimText(`[${speaker}] ${data.text}`);
          }
        });

        whysperAPI.onDualSpeechStatus((event, data) => {
          if (data && data.status) {
            addMessage(data.status, 'system');
          }
        });

        whysperAPI.onDualSpeechError((event, data) => {
          if (data && data.error) {
            addMessage(`Dual speech error: ${data.error}`, 'error');
            handleRecordingStopped();
          }
        });
      }

      // UI Event Listeners
      if (clearHistoryBtn) {
        clearHistoryBtn.addEventListener('click', () => clearChatHistory());
      }

      if (micButton) {
        micButton.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();

          console.log('MIC button clicked, isRecordingAudio:', isRecordingAudio);

          if (!isInteractive) {
            addMessage('Window is in non-interactive mode. Press Alt+A to enable interaction.', 'error');
            return;
          }

          try {
            if (isRecordingAudio) {
              console.log('Stopping Azure Speech recording...');
              await window.electronAPI.stopDualSpeechRecognition();
              isRecordingAudio = false;
              handleRecordingStopped();
            } else {
              console.log('Starting Azure Speech recording...');
              await window.electronAPI.startDualSpeechRecognition();
              isRecordingAudio = true;
              handleRecordingStarted();
              addMessage('Recording audio from microphone and system via Azure Speech...', 'system');
            }
          } catch (error) {
            console.error('Audio recording error:', error);
            addMessage("Recording error: " + (error.message || error), 'error');
            isRecordingAudio = false;
            handleRecordingStopped();
          }
        });
      }

      if (sendButton) {
        sendButton.addEventListener('click', async () => {
          const text = messageInput.value.trim();
          if (text) {
            addMessage(text, 'user');
            messageInput.value = '';
            
            // Show thinking indicator after user message
            setTimeout(() => {
              showThinkingIndicator();
            }, 300);
            
            // Send to main process for session memory storage and LLM processing
            try {
              if (whysperAPI && whysperAPI.sendChatMessage) {
                await whysperAPI.sendChatMessage(text);
              }
            } catch (error) {
              console.error('Failed to send chat message to main process:', error);
            }
          }
        });
      }

      // Auto-resize for multiline textarea
      function autoGrow(el) {
        if (!el) return;
        el.style.height = 'auto';
        const max = 140; // keep within container limits
        el.style.height = Math.min(el.scrollHeight, max) + 'px';
      }
      if (messageInput) {
        autoGrow(messageInput);
        messageInput.addEventListener('input', () => autoGrow(messageInput));
      }

      // Replace keypress with keydown to support Shift+Enter for newline and Enter to send
      if (messageInput) {
        messageInput.addEventListener('keydown', async (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const text = messageInput.value.trim();
            if (text) {
              addMessage(text, 'user');
              messageInput.value = '';
              autoGrow(messageInput);
              setTimeout(() => { showThinkingIndicator(); }, 300);
              try {
                if (whysperAPI && whysperAPI.sendChatMessage) {
                  await whysperAPI.sendChatMessage(text);
                }
              } catch (error) {
                console.error('Failed to send chat message to main process:', error);
              }
            }
          }
          // If Shift+Enter, allow default to insert newline
        });
      }

      // Global keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.altKey && e.key === 'r') {
          e.preventDefault();
          if (!isInteractive || !speechAvailable) return;
          micButton && micButton.click();
        }
      });

      // Initialize
      if (!chatHistory || chatHistory.length === 0) {
        addMessage('Recording in Progress. press Alt+R to stop recording.', 'system');
      }
    </script>
  </body>
</html>